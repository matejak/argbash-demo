#!/bin/bash

# ARG_POSITIONAL_INF([directory],[directories to list],[0],[.])
# ARG_OPTIONAL_SINGLE([width],[w],[Width of the output])
# ARG_OPTIONAL_BOOLEAN([almost-all],[A],[Omit implicit '.' and '..' directories in the listing])
# ARG_HELP([Script that tells what 'ls' would do.])
# ARG_OPTION_STACKING([none])
# ARGBASH_SET_DELIM([ ])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.5.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}


# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_directory=(".")
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_width=
_arg_almost_all=off

print_help ()
{
	printf "%s\n" "Script that tells what 'ls' would do."
	printf 'Usage: %s [-w|--width <arg>] [-A|--(no-)almost-all] [-h|--help] [<directory-1>] ... [<directory-n>] ...\n' "$0"
	printf "\t%s\n" "<directory>: directories to list (defaults for <directory>: '.')"
	printf "\t%s\n" "-w,--width: Width of the output (no default)"
	printf "\t%s\n" "-A,--almost-all,--no-almost-all: Omit implicit '.' and '..' directories in the listing (off by default)"
	printf "\t%s\n" "-h,--help: Prints help"
	echo
	echo 'Short options stacking mode is not supported.'
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-w|--width)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_width="$2"
				shift
				;;
			-A|--no-almost-all|--almost-all)
				_arg_almost_all="on"
				test "${1:0:5}" = "--no-" && _arg_almost_all="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


assign_positional_args ()
{
	_positional_names=()
	_our_args=$((${#_positionals[@]} - ${#_positional_names[@]}))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names+=("_arg_directory[$((ii + 0))]")
	done

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

#

printf "Will list directories: "
printf "'%s', " "${_arg_directory[@]}"
printf "\n"

if test -n "$_arg_width"
then
	printf "Padding the output to '%d' terminal columns.\n" "$_arg_width"
fi

test "$_arg_almost_all" = on && echo "Oitting implicit '.' and '..' directories in the listing."

#
# ] <-- needed because of Argbash
